#include<bits/stdc++.h>

using namespace std;
class Queue {
  int * arr;
  int start, end, currSize, maxSize;
  public:
    Queue() {
      arr = new int[16];
      start = -1;
      end = -1;
      currSize = 0;
    }

  Queue(int maxSize) {
    ( * this).maxSize = maxSize;
    arr = new int[maxSize];
    start = -1;
    end = -1;
    currSize = 0;
  }
  void push(int newElement) {
    if (currSize == maxSize) {
      cout << "Queue is full\nExiting..." << endl;
      exit(1);
    }
    if (end == -1) {
      start = 0;
      end = 0;
    } else
      end = (end + 1) % maxSize;
    arr[end] = newElement;
    cout << "The element pushed is " << newElement << endl;
    currSize++;
  }
  int pop() {
    if (start == -1) {
      cout << "Queue Empty\nExiting..." << endl;
    }
    int popped = arr[start];
    if (currSize == 1) {
      start = -1;
      end = -1;
    } else
      start = (start + 1) % maxSize;
    currSize--;
    return popped;
  }
  int top() {
    if (start == -1) {
      cout << "Queue is Empty" << endl;
      exit(1);
    }
    return arr[start];
  }
  int size() {
    return currSize;
  }

};

int main() {
  Queue q(6);
  q.push(4);
  q.push(14);
  q.push(24);
  q.pop();
  

  return 0;
}


#include <iostream>
using namespace std;
#define SIZE 5
int A[SIZE];
int front = -1;
int rear = -1;

bool isempty()
{
 if(front == -1 && rear == -1)
 return true;
 else
 return false;
}

void add ( int value )
{
 if ((rear + 1)%SIZE == front)
    cout<<"Queue is full \n";
 else
 {
  if( front == -1)
     front = 0;
 rear = (rear+1)%SIZE;
   A[rear] = value;
 }
}

void remov ( )
{
 if( isempty() )
  cout<<"Queue is empty\n";
 else
 if( front == rear )
  front = rear = -1;
 else
  front = (front + 1)%SIZE;
}

void showfront( )
{
 if( isempty())
 cout<<"Queue is empty\n";
 else
 cout<<"element at front is:"<<A[front];
}

void display()
{
 if(isempty())
  cout<<"Queue is empty\n";
 else
 {
  int i;
  if( front <= rear )
  {
   for( i=front ; i<= rear ; i++)
   cout<<A[i]<<" ";
  }
  else
  {
   i=front;
   while( i < SIZE)
   {
   cout<<A[i]<<" ";
   i++;
   }
   i=0;
   while( i <= rear)
   {
   cout<<A[i]<<" ";
   i++;
   }
  }
 }
}

int main()
{
 add(2);
 add(3);
 remov();
 display();
 return 0;
}

#include <bits/stdc++.h>
using namespace std;

struct QNode {
	int data;
	QNode* next;
	QNode(int d)
	{
		data = d;
		next = NULL;
	}
};

struct Queue {
	QNode *front, *rear;
	Queue() { front = rear = NULL; }

	void enQueue(int x)
	{

		QNode* temp = new QNode(x);

		if (rear == NULL) {
			front = rear = temp;
			return;
		}

		rear->next = temp;
		rear = temp;
	}

	void deQueue()
	{

		if (front == NULL){
		    cout<<"underflow"<<endl;
			return;}

		QNode* temp = front;
		front = front->next;

		if (front == NULL)
			rear = NULL;

		delete (temp);
	}
};

int main()
{

	Queue q;
	q.enQueue(10);
	q.enQueue(20);
	q.deQueue();
	q.deQueue();
	q.deQueue();
}




#include <bits/stdc++.h>
using namespace std;

typedef struct node
{
	int data;

	int priority;

	struct node* next;

} Node;

Node* newNode(int d, int p)
{
	Node* temp = (Node*)malloc(sizeof(Node));
	temp->data = d;
	temp->priority = p;
	temp->next = NULL;

	return temp;
}


int peek(Node** head)
{
	return (*head)->data;
}

void remove(Node** head)
{
	Node* temp = *head;
	(*head) = (*head)->next;
	free(temp);
}

void add(Node** head, int d, int p)
{
	Node* start = (*head);

	Node* temp = newNode(d, p);

	if ((*head)->priority > p)
	{
		
		temp->next = *head;
		(*head) = temp;
	}
	else
	{
		

		while (start->next != NULL &&
			start->next->priority < p)
		{
			start = start->next;
		}

		temp->next = start->next;
		start->next = temp;
	}
}

int isEmpty(Node** head)
{
	return (*head) == NULL;
}

int main()
{
	

	Node* pq = newNode(4, 1);
	add(&pq, 5, 2);
	add(&pq, 6, 3);
	add(&pq, 7, 0);

	while (!isEmpty(&pq))
	{
		cout << " " << peek(&pq);
		remove(&pq);
	}
	return 0;
}



#include <bits/stdc++.h>

class Node {
public:
    int data;
    int priority;
    Node* next;

    Node(int value, int prio) : data(value), priority(prio), next(nullptr) {}
};

class PriorityQueue {
private:
    Node* front;

public:
    PriorityQueue() : front(nullptr) {}

    void enqueue(int value, int priority) {
        Node* newNode = new Node(value, priority);

        if (!front || priority < front->priority) {
            newNode->next = front;
            front = newNode;
        } else {
            Node* current = front;
            while (current->next && priority >= current->next->priority) {
                current = current->next;
            }
            newNode->next = current->next;
            current->next = newNode;
        }
    }

    int dequeue() {
        if (!front) {
            std::cerr << "Queue is empty." << std::endl;
            return -1; 
        }

        int value = front->data;
        Node* temp = front;
        front = front->next;
        delete temp;

        return value;
    }

    bool isEmpty() {
        return front == nullptr;
    }

    void display() {
        Node* current = front;
        while (current) {
            std::cout << current->data << " ";
            current = current->next;
        }
        std::cout << std::endl;
    }
};

int main() {
    PriorityQueue queue;
    queue.enqueue(1, 3);
    queue.enqueue(2, 1);
    queue.enqueue(3, 2);
    return 0;
}



#include <iostream>

const int MAX_SIZE = 100;

class PriorityQueue {
public:
    PriorityQueue() {
        s = 0;
    }

    void push(int v, int p) {
        if (s >= MAX_SIZE) {
            std::cout << "Queue is full. Cannot push." << std::endl;
            return;
        }
        q[s][0] = v;
        q[s][1] = p;
        s++;

        int i = s - 1;
        int p_i = (i - 1) / 2;

        while (i > 0 && q[i][1] < q[p_i][1]) {
            swap(i, p_i);
            i = p_i;
            p_i = (i - 1) / 2;
        }
    }

    int pop() {
        if (s == 0) {
            std::cout << "Queue is empty. Cannot pop." << std::endl;
            return -1;
        }

        int top = q[0][0];
        s--;

        q[0][0] = q[s][0];
        q[0][1] = q[s][1];

        int i = 0;

        while (true) {
            int l = 2 * i + 1;
            int r = 2 * i + 2;
            int m = i;

            if (l < s && q[l][1] < q[m][1]) {
                m = l;
            }

            if (r < s && q[r][1] < q[m][1]) {
                m = r;
            }

            if (m == i) {
                break;
            }

            swap(i, m);
            i = m;
        }

        return top;
    }

    bool empty() {
        return s == 0;
    }

private:
    int q[MAX_SIZE][2];
    int s;

    void swap(int a, int b) {
        int t_v = q[a][0];
        int t_p = q[a][1];
        q[a][0] = q[b][0];
        q[a][1] = q[b][1];
        q[b][0] = t_v;
        q[b][1] = t_p;
    }
};

int main() {
    PriorityQueue pq;

    pq.push(3, 2);
    pq.push(5, 1);
    pq.push(7, 3);

    while (!pq.empty()) {
        std::cout << pq.pop() << " ";
    }

    return 0;
}


#include <bits/stdc++.h>
using namespace std;

const int MAX_SIZE = 100;

class Deque {
public:
    Deque() {
        size = 0;
        front = 0;
        rear = -1;
    }

    void addFront(int val) {
        if (size >= MAX_SIZE) {
            cout << "Deque is full. Cannot pushFront." << endl;
            return;
        }
        front = (front - 1 + MAX_SIZE) % MAX_SIZE;
        arr[front] = val;
        size++;
    }

    void addBack(int val) {
        if (size >= MAX_SIZE) {
           cout << "Deque is full. Cannot pushBack." << endl;
            return;
        }
        rear = (rear + 1) % MAX_SIZE;
        arr[rear] = val;
        size++;
    }

    int popFront() {
        if (isEmpty()) {
            cout << "Deque is empty. Cannot popFront." << endl;
            return -1;
        }
        int val = arr[front];
        front = (front + 1) % MAX_SIZE;
        size--;
        return val;
    }

    int popBack() {
        if (isEmpty()) {
            cout << "Deque is empty. Cannot popBack." << endl;
            return -1;
        }
        int val = arr[rear];
        rear = (rear - 1 + MAX_SIZE) % MAX_SIZE;
        size--;
        return val;
    }

    bool isEmpty() {
        return size == 0;
    }

    int getSize() {
        return size;
    }

private:
    int arr[MAX_SIZE];
    int size;
    int front;
    int rear;
};

int main() {
    Deque Q;

    Q.addBack(1);
    Q.addBack(2);
    Q.addFront(3);
    Q.addFront(4);

    cout << "Deque size: " << Q.getSize() << endl;

    while (!Q.isEmpty()) {
        cout << Q.popFront() << " ";
    }

    cout << endl;

    return 0;
}



#include <bits/stdc++.h>

using namespace std;

class Node {
public:
    int data;
    Node* next;
    Node* prev;

    Node(int val) {
        data = val;
        next = nullptr;
        prev = nullptr;
    }
};

class Deque {
public:
    Deque() {
        front = nullptr;
        rear = nullptr;
        size = 0;
    }

    void pushFront(int val) {
        Node* newNode = new Node(val);
        if (isEmpty()) {
            front = newNode;
            rear = newNode;
        } else {
            newNode->next = front;
            front->prev = newNode;
            front = newNode;
        }
        size++;
    }

    void pushBack(int val) {
        Node* newNode = new Node(val);
        if (isEmpty()) {
            front = newNode;
            rear = newNode;
        } else {
            rear->next = newNode;
            newNode->prev = rear;
            rear = newNode;
        }
        size++;
    }

    int popFront() {
        if (isEmpty()) {
            cout << "Deque is empty. Cannot popFront." << endl;
            return -1;
        }

        int val = front->data;
        Node* temp = front;

        if (front == rear) {
            front = nullptr;
            rear = nullptr;
        } else {
            front = front->next;
            front->prev = nullptr;
        }

        delete temp;
        size--;
        return val;
    }

    int popBack() {
        if (isEmpty()) {
            cout << "Deque is empty. Cannot popBack." << endl;
            return -1;
        }

        int val = rear->data;
        Node* temp = rear;

        if (front == rear) {
            front = nullptr;
            rear = nullptr;
        } else {
            rear = rear->prev;
            rear->next = nullptr;
        }

        delete temp;
        size--;
        return val;
    }

    bool isEmpty() {
        return size == 0;
    }

    int getSize() {
        return size;
    }

private:
    Node* front;
    Node* rear;
    int size;
};

int main() {
    Deque deque;

    deque.pushBack(1);
    deque.pushBack(2);
    deque.pushFront(3);
    deque.pushFront(4);

    cout << "Deque size: " << deque.getSize() << endl;

    while (!deque.isEmpty()) {
        cout << deque.popFront() << " ";
    }
    deque.popFront();

    cout << endl;

    return 0;
}

